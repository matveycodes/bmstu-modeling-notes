\section{Лекция №10 (20.11.2023)}

\subsection{Управляющая программа имитационной модели}

Если программа-имитатор от источника информации обслуживающего аппарата, буферной памяти отображает работу отдельных устройств, то управляющая программа имитирует алгоритм взаимодействия всех устройств системы.

Управляющая программа реализуется по следующим принципам.

\subsubsection{Принцип $\mathbf{\Delta t}$}

Принцип $\Delta t$ заключается в последовательном анализе состояний всех блоков системы в момент времени ${t + \Delta t}$ по заданному состоянию блоков в момент времени $t$. При этом новое состояние определяется в соответствии с их алгоритмическим описанием с учетом случайных факторов, задаваемых распределениями вероятности. В результате этого решения проводится анализ, позволяющий определить, какие общесистемные события должны имитироваться в программной модели на данный момент времени.

Основной недостаток принципа $\Delta t$~--- значительные затраты машинного времени на анализ и контроль правильности функционирования всей системы. При недостаточно малом $\Delta t$ появляется опасность пропуска отдельных событий в системе, что исключает возможность получения правильных результатов при моделировании.

\subsubsection{Событийный принцип}

Характерное свойство моделируемых систем обработки информации~--- то, что состояния отдельных устройств изменяются в дискретные моменты времени, совпадающие с моментами поступления сообщений в систему, окончания решения той или иной задачи, возникновения аварийных сигналов. Поэтому моделирование и
продвижение текущего времени в системе удобно производить, используя \textit{событийный принцип}, при реализации которого состояния всех блоков имитационной (программной) модели анализируется лишь в момент появления какого-либо события. Момент наступления следующего события определяется минимальным значением из списка будущих событий, представляющего собой совокупность \textbf{ближайшего} изменения состояния каждого из блоков системы.

\image
{.75\textwidth}
{10/inc/events}
{Схема событийного принципа}

Обозначения:

\begin{itemize}
    \item $t_{11}$, $t_{12}$~--- моменты появления сообщений на выходе источника информации;
    \item $b_1$~--- время обслуживания первого сообщения;
    \item $t_{3i}$~--- моменты времени сбора статистики;
    \item $t_{41}$~--- момент времени окончания моделирования;
    \item SBS --- список будущих событий.
\end{itemize}

\subsubsection{Методика реализации событийной модели}

Для всех активных блоков (блоков, порождающих событий) заводят свой элемент
в одномерном массиве (списке будущих событий~--- СБС).

В качестве подготовительной операции в СБС заносят время ближайшего события от любого активного блока. Активизируя программный имитатор источника, вырабатывают псевдослучайную величину $a_0$, определяющую момент появления первого сообщения $t_{11}$, и эту величину заносят в СБС. Активизируя имитатор обслуживающего аппарата, вырабатывают псевдослучайную величину $b_0$, определяющую момент времени $t_{21}$, которую также заносят в СБС. Момент времени $t_{31}$ (момент первого сбора статистики) определяется равным стандартному шагу сбору статистики и также заносится в СБС. В этот же список заносят время окончания моделирования $t_{41}$. На этом подготовительный этап заканчивается, и далее начинается <<протяжка>> модельного времени в соответствии с алгоритмом.

\image
{.5\textwidth}
{10/inc/algorithm}
{Схема алгоритма}

\begin{enumerate}
    \item В списке будущих событий определяем минимальное значение и его порядковый номер.
    \item Реализуются события, порождаемые блоком со временем $t_{11}$. Реализация этого события заключается в том, что само сообщение записывается в буферную память, и с помощью программного имитатора источника вырабатывается момент появления следующего сообщения $t_{12}$. Это время помещается в список будущих событий вместо $t_{11}$. Повторяется до достижения времени окончания моделирования.
    \item Выводим статистику по каждому устройству, связанному с событием.
\end{enumerate}

Два описанных выше принципа являются универсальными методами протяжки модального времени. Выбор метода необходимо осуществлять исходя из распределения событий во времени. Во многих реальных системах распределение событий далеко не однородно (события группируются во времени). Образование групп связано с наступлением какого-либо <<значимого>> события, которое начинает определенную последовательность действий с соответствующими событиями, имеющими высокую плотность на близлежащем временном интервале. Такой интервал называется \textit{пиковым}, а распределение событий~--- \textit{квазисинхронным}. Примером таких сложных систем может являться цифровая сеть, в которой синхронизирующие сигналы переключают большое количество триггеров.

Этот алгоритм был разработан для специальных дискретных систем, в которых присутствует квазисинхронное распределение событий. Особенностью алгоритма является автоматическая адаптация к распределению событий.

Метод реализуется так, что на пиковых интервалах он приближается к методу $\Delta t$, а вне пиковых~--- к событийному методу с большим шагом времени.

Алгоритм основан на использовании иерархической структуры циркулярных списков. Список первого уровня содержит $n_1$ элементов и описывает планируемое событие в пиковых интервалах. Число $n_1$ представляет собой разбиение пикового интервала на более мелкие участки, с каждым из которых связан список событий, произошедших за этот интервал. Списки второго уровня и выше являются масштабирующими списками, количество элементов которых равно константному значению $n_2$, которое характеризует коэффициент масштабирования временных интервалов.

Алгоритм протяжки модельного времени заключается в последовательном поиске непустых элементов в самом верхнем циркулярном списке с большим шагом и дальнейшим спуском на нижние уровни, тем самым уменьшая шаг протяжки модельного времени.

\subsection{Лабораторная работа №4}

Есть генератор, который выдает сообщения в систему, распределенные по равномерному закону. Есть очередь, куда сообщения поступают в режиме FIFO, и обрабатываются обслуживающим аппаратом. Обслуживающий аппарат работает по закону первой лабораторной работы (по варианту).

Задача~--- найти максимальный объем очереди, при котором сообщения не теряются, используя два алгоритма протяжки модельного времени~--- $\Delta t$ и событийный.

Часть сообщений (заранее заданная в процентном соотношении от выходного потока) заново поступает в очередь на обработку. Таким образом, максимальная длина очереди должна быть другой.

Должен быть GUI.